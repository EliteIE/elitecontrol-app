// js/elitecontrol-data.js
const ELITE_CONTROL_DATA_KEY = 'eliteControlData';

const TIPOS_MOVIMENTACAO = [
    "Entrada (compra)", "Saída (venda)", "Ajuste (inventário)",
    "Devolução (cliente)", "Devolução (fornecedor)",
    "Transferência (entre depósitos)", "Perda (avaria/extravio)"
];

function getInitialData() {
    return {
        usuarios: [
            { id: 1, nome: "Alice Admin", email: "admin@elitecontrol.com", senha: "hashed_password_admin", perfil: "gerente", ativo: true, ultimoAcesso: new Date().toISOString(), dataCadastro: new Date(Date.now() - 86400000 * 90).toISOString() },
            { id: 2, nome: "Bob Estoquista", email: "bob@elitecontrol.com", senha: "hashed_password_bob", perfil: "inventario", ativo: true, ultimoAcesso: new Date().toISOString(), dataCadastro: new Date(Date.now() - 86400000 * 60).toISOString() },
            { id: 3, nome: "Charlie Vendedor", email: "charlie@elitecontrol.com", senha: "hashed_password_charlie", perfil: "vendas", ativo: true, ultimoAcesso: new Date(Date.now() - 86400000 * 5).toISOString(), dataCadastro: new Date(Date.now() - 86400000 * 30).toISOString() }
        ],
        produtos: [
            { sku: "EC-001", nome: "Teclado Mecânico RGB", categoria: "Periféricos", precoCusto: 150.00, precoVenda: 299.90, quantidade: 50, estoqueMinimo: 10, fornecedor: "TechImports SA", ultimaAtualizacao: new Date(Date.now() - 86400000 * 2).toISOString(), dataCadastro: new Date(Date.now() - 86400000 * 60).toISOString() },
            { sku: "EC-002", nome: "Mouse Óptico Sem Fio", categoria: "Periféricos", precoCusto: 45.00, precoVenda: 89.90, quantidade: 120, estoqueMinimo: 20, fornecedor: "OfficeSupplies Ltda", ultimaAtualizacao: new Date().toISOString(), dataCadastro: new Date(Date.now() - 86400000 * 50).toISOString() },
            { sku: "EC-003", nome: "Monitor LED 24 Full HD", categoria: "Monitores", precoCusto: 600.00, precoVenda: 999.00, quantidade: 30, estoqueMinimo: 5, fornecedor: "DisplayTech Co.", ultimaAtualizacao: new Date(Date.now() - 86400000).toISOString(), dataCadastro: new Date(Date.now() - 86400000 * 70).toISOString() },
            { sku: "EC-004", nome: "SSD NVMe 1TB", categoria: "Armazenamento", precoCusto: 350.00, precoVenda: 599.90, quantidade: 75, estoqueMinimo: 15, fornecedor: "KingFast", ultimaAtualizacao: new Date().toISOString(), dataCadastro: new Date(Date.now() - 86400000 * 40).toISOString() }
        ],
        vendas: [
            { id: 1001, data: new Date(Date.now() - 86400000 * 35).toISOString(), cliente: "João Silva", vendedorId: 3, itens: [{ sku: "EC-002", nomeProduto: "Mouse Óptico Sem Fio", quantidade: 2, precoUnitario: 89.90, subtotal: 179.80 }], subtotalItens: 179.80, desconto: 0, total: 179.80, formaPagamento: "Cartão de Crédito", status: "finalizada" },
            { id: 1002, data: new Date(Date.now() - 86400000 * 32).toISOString(), cliente: "Maria Oliveira", vendedorId: 1, itens: [{ sku: "EC-001", nomeProduto: "Teclado Mecânico RGB", quantidade: 1, precoUnitario: 299.90, subtotal: 299.90 }], subtotalItens: 299.90, desconto: 10, total: 289.90, formaPagamento: "PIX", status: "finalizada" },
            { id: 1003, data: new Date(Date.now() - 86400000 * 28).toISOString(), cliente: "Carlos Pereira", vendedorId: 3, itens: [{ sku: "EC-003", nomeProduto: "Monitor LED 24 Full HD", quantidade: 1, precoUnitario: 999.00, subtotal: 999.00 }], subtotalItens: 999.00, desconto: 0, total: 999.00, formaPagamento: "Dinheiro", status: "finalizada" },
            { id: 1004, data: new Date(Date.now() - 86400000 * 15).toISOString(), cliente: "Ana Costa", vendedorId: 1, itens: [{ sku: "EC-004", nomeProduto: "SSD NVMe 1TB", quantidade: 1, precoUnitario: 599.90, subtotal: 599.90 }], subtotalItens: 599.90, desconto: 20, total: 579.90, formaPagamento: "Cartão de Débito", status: "finalizada" },
            { id: 1005, data: new Date(Date.now() - 86400000 * 10).toISOString(), cliente: "Lucas Martins", vendedorId: 3, itens: [{ sku: "EC-002", nomeProduto: "Mouse Óptico Sem Fio", quantidade: 3, precoUnitario: 89.90, subtotal: 269.70 }, { sku: "EC-001", nomeProduto: "Teclado Mecânico RGB", quantidade: 1, precoUnitario: 299.90, subtotal: 299.90 }], subtotalItens: 569.60, desconto: 0, total: 569.60, formaPagamento: "PIX", status: "finalizada" }
        ],
        configuracoes: {
            nomeEmpresa: "EliteControl Soluções Ltda.",
            enderecoEmpresa: "Av. Principal, 1000, Centro, Cidade Exemplo - EX",
            telefoneEmpresa: "(XX) XXXXX-XXXX",
            emailEmpresa: "contato@elitecontrol.com",
            logoUrlEmpresa: "https://placehold.co/200x60/0ea5e9/ffffff?text=EliteControl",
            moeda: "BRL",
            formatoNumero: "pt-BR",
            fusoHorario: "America/Sao_Paulo",
            estoqueNivelMinimoPadrao: 10,
            alertaEstoqueAtivado: true,
            backupFrequencia: "diario",
            ultimoBackupCompleto: null,
            integracoes: {
                ecommerceAtiva: false, ecommercePlataforma: "", ecommerceApiKey: "", ecommerceApiSecret: "", ecommerceUrlLoja: "", ecommerceSincProdutosAtiva: false, ecommerceImportarPedidosAtiva: false, ecommerceAtualizarPrecosAtiva: false, ecommerceUltimaSinc: null,
                fiscalAtiva: false, fiscalTipoSistema: "", fiscalApiKey: "", fiscalCertificadoDigitalValidade: null,
                pagamentosAtiva: false, pagamentosProvedor: "", pagamentosPublicKey: "", pagamentosAccessToken: "", pagamentosConciliacaoAtiva: false,
                contabilidadeAtiva: false, contabilidadeSistema: "", contabilidadeFormatoExportacao: "CSV", contabilidadeContaPadraoVendas: "", contabilidadeContaPadraoCustos: ""
            }
        },
        notificacoes: [
             { id: 1, tipo: "estoque", titulo: "Estoque Baixo: Teclado Mecânico", mensagem: "O produto Teclado Mecânico RGB (EC-001) está com apenas 5 unidades.", timestamp: new Date(Date.now() - 3600000).toISOString(), lida: false, destinatarios: ["gerente", "inventario"], acao: { tipo: "link", valor: "#products/EC-001" } },
        ],
        movimentacoesEstoque: [],
        iaInsights: {
            demandForecasts: [], detectedAnomalies: [], pricingSuggestions: [],
            virtualAssistantInteractions: [], smartRecommendationsLog: [], nlpAnalysisCache: {}
        },
        logsIntegracao: []
    };
}

function getData() { const d = localStorage.getItem(ELITE_CONTROL_DATA_KEY); return d ? JSON.parse(d) : inicializarDados(); }
function saveData(data) { localStorage.setItem(ELITE_CONTROL_DATA_KEY, JSON.stringify(data)); }
function gerarIdUnico(lista) { return lista.length > 0 ? Math.max(...lista.map(item => item.id)) + 1 : Date.now(); }
function inicializarDados() {
    const d = getInitialData();
    if (!d.movimentacoesEstoque || d.movimentacoesEstoque.length === 0) {
        d.movimentacoesEstoque = [];
        (d.vendas || []).forEach(venda => { // Adicionado (d.vendas || [])
            if (venda.status === 'finalizada') {
                (venda.itens || []).forEach(item => { // Adicionado (venda.itens || [])
                    d.movimentacoesEstoque.push({ id: gerarIdUnico(d.movimentacoesEstoque), tipo: "Saída (venda)", data: venda.data, produtoSku: item.sku, quantidade: -Math.abs(item.quantidade), valorUnitario: item.precoUnitario, origem: "Estoque Principal", destino: venda.cliente || "Cliente", documento: `VENDA-${venda.id}`, responsavel: venda.vendedorId, observacao: `Item da venda #${venda.id}` });
                });
            }
        });
    }
    saveData(d);
    return d;
}

const permissoes = {
    gerente: { dashboard: true, inventario: { visualizar: true, adicionar: true, editar: true, remover: true, ajustar: true, exportar: true, importar: true, movimentacoes: true }, vendas: { visualizar: true, registrar: true, cancelar: true, relatorios: true, historicoCompleto: true, relatoriosGerenciais: true }, financeiro: { visualizar: true, relatorios: true }, configuracoes: { sistema: true, usuarios: true, empresa: true, integracoes: true, backupRestore: true }, ia: { previsaoDemanda: true, deteccaoAnomalias: true, precificacaoDinamica: true, assistenteVirtual: true, recomendacaoInteligente: true, nlp: true, visaoComputacional: false } },
    inventario: { dashboard: true, inventario: { visualizar: true, adicionar: true, editar: true, remover: false, ajustar: true, exportar: true, importar: true, movimentacoes: true }, vendas: { visualizar: false, registrar: false, cancelar: false, relatorios: true, historicoCompleto: false, relatoriosGerenciais: 'parcial' }, financeiro: { visualizar: false, relatorios: false }, configuracoes: { sistema: false, usuarios: false, empresa: false, integracoes: false, backupRestore: false }, ia: { previsaoDemanda: true, deteccaoAnomalias: false, precificacaoDinamica: false, assistenteVirtual: false, recomendacaoInteligente: 'parcial_estoque', nlp: 'busca', visaoComputacional: false } },
    vendas: { dashboard: true, inventario: { visualizar: true, adicionar: false, editar: false, remover: false, ajustar: false, exportar: false, importar: false, movimentacoes: false }, vendas: { visualizar: true, registrar: true, cancelar: false, relatorios: true, historicoCompleto: false, relatoriosGerenciais: false }, financeiro: { visualizar: false, relatorios: false }, configuracoes: { sistema: false, usuarios: false, empresa: false, integracoes: false, backupRestore: false }, ia: { previsaoDemanda: false, deteccaoAnomalias: false, precificacaoDinamica: false, assistenteVirtual: true, recomendacaoInteligente: 'parcial_vendas', nlp: 'busca', visaoComputacional: false } }
};
function verificarPermissao(perfilUsuario, funcionalidadeCompleta) { if (!perfilUsuario || !permissoes[perfilUsuario]) { return false; } const p = funcionalidadeCompleta.split('.'); let permNivel = permissoes[perfilUsuario]; for (const part of p) { if (permNivel && typeof permNivel === 'object' && part in permNivel) { permNivel = permNivel[part]; } else if (typeof permNivel === 'string' && (permNivel === 'parcial' || permNivel.startsWith('parcial_')) && p.length > 1) { return true; } else if (typeof permNivel === 'boolean' && part === funcionalidadeCompleta.split('.').pop()) { return permNivel; } else if (typeof permNivel === 'string' && permNivel === funcionalidadeCompleta.split('.').pop()) {return true;} else { return false; } } return (typeof permNivel === 'boolean' || typeof permNivel === 'string') ? !!permNivel : false; }

function obterUsuarios() { const d = getData(); return d.usuarios || []; }
function autenticarUsuario(email, senha) { const usuarios = obterUsuarios(); const usuario = usuarios.find(u => u.email === email && u.ativo); if (usuario) { if (usuario.senha === senha || usuario.senha === `hashed_${senha}`) { const data = getData(); const userIndex = data.usuarios.findIndex(u_1 => u_1.id === usuario.id); if (userIndex !== -1) { data.usuarios[userIndex].ultimoAcesso = new Date().toISOString(); saveData(data); } return { ...usuario }; } } return null; }
function obterUsuarioPorId(userId) { return obterUsuarios().find(u => u.id === parseInt(userId)) || null; }
function adicionarUsuarioSistema(userData) { const data = getData(); if (data.usuarios.some(u => u.email === userData.email)) { throw new Error(`Usuário com email ${userData.email} já existe.`); } if (!userData.senha || userData.senha.length < 6) { throw new Error("A senha é obrigatória e deve ter no mínimo 6 caracteres."); } const novoUsuario = { id: gerarIdUnico(data.usuarios), nome: userData.nome, email: userData.email, senha: `hashed_${userData.senha}`, perfil: userData.perfil, ativo: userData.ativo !== undefined ? userData.ativo : true, ultimoAcesso: null, dataCadastro: new Date().toISOString() }; data.usuarios.push(novoUsuario); saveData(data); adicionarNotificacao({ tipo: "sistema", titulo: "Novo Usuário Criado", mensagem: `Usuário <span class="math-inline">\{novoUsuario\.nome\} \(</span>{novoUsuario.email}) foi adicionado.`, destinatarios: ["gerente"] }); return novoUsuario; }
function atualizarUsuarioSistema(userId, dadosAtualizados) { const data = getData(); const userIndex = data.usuarios.findIndex(u => u.id === parseInt(userId)); if (userIndex === -1) { throw new Error(`Usuário com ID ${userId} não encontrado.`); } if (dadosAtualizados.email && dadosAtualizados.email !== data.usuarios[userIndex].email) { if (data.usuarios.some(u_1 => u_1.email === dadosAtualizados.email && u_1.id !== parseInt(userId))) { throw new Error(`O email ${dadosAtualizados.email} já está em uso.`); } } const usuarioAtualizado = { ...data.usuarios[userIndex] }; if (dadosAtualizados.nome) usuarioAtualizado.nome = dadosAtualizados.nome; if (dadosAtualizados.email) usuarioAtualizado.email = dadosAtualizados.email; if (dadosAtualizados.perfil) usuarioAtualizado.perfil = dadosAtualizados.perfil; if (dadosAtualizados.ativo !== undefined) usuarioAtualizado.ativo = dadosAtualizados.ativo; if (dadosAtualizados.senha && dadosAtualizados.senha.trim() !== "") { if (dadosAtualizados.senha.length < 6) { throw new Error("A nova senha deve ter no mínimo 6 caracteres."); } usuarioAtualizado.senha = `hashed_${dadosAtualizados.senha}`; } data.usuarios[userIndex] = usuarioAtualizado; saveData(data); adicionarNotificacao({ tipo: "sistema", titulo: "Usuário Atualizado", mensagem: `Dados do usuário ${usuarioAtualizado.nome} foram atualizados.`, destinatarios: ["gerente"] }); return usuarioAtualizado; }

function obterConfiguracoesGerais() { const data = getData(); const defaultConfig = getInitialData().configuracoes; const mergeDeep = (target, source) => { for (const key in source) { if (source[key] instanceof Object && key in target && target[key] instanceof Object) { mergeDeep(target[key], source[key]); } else { target[key] = source[key]; } } return target; }; const mergedConfig = mergeDeep(JSON.parse(JSON.stringify(defaultConfig)), data.configuracoes || {}); return mergedConfig; }
function atualizarConfiguracoesGerais(novasConfiguracoes) { const data = getData(); const configAtuais = obterConfiguracoesGerais(); const mergeConfigs = (target, source) => { for (const key in source) { if (source[key] instanceof Object && source[key] !== null && !Array.isArray(source[key])) { if (!target[key] || typeof target[key] !== 'object') { target[key] = {}; } mergeConfigs(target[key], source[key]); } else { target[key] = source[key]; } } }; const configuracoesAtualizadas = JSON.parse(JSON.stringify(configAtuais)); mergeConfigs(configuracoesAtualizadas, novasConfiguracoes); data.configuracoes = configuracoesAtualizadas; saveData(data); adicionarNotificacao({ tipo: "sistema", titulo: "Configurações Atualizadas", mensagem: "As configurações gerais foram atualizadas.", destinatarios: ["gerente"] }); return data.configuracoes; }
function registrarUltimoBackup() { const data = getData(); if (data.configuracoes) { data.configuracoes.ultimoBackupCompleto = new Date().toISOString(); saveData(data); } }

function adicionarNotificacao(notifInput) { const data = getData(); const novoLog = { id: gerarIdUnico(data.notificacoes || []), timestamp: new Date().toISOString(), lida: false, ...notifInput }; if (!data.notificacoes) data.notificacoes = []; data.notificacoes.unshift(novoLog); if (data.notificacoes.length > 50) data.notificacoes.pop(); saveData(data); document.dispatchEvent(new CustomEvent('novaNotificacao', { detail: novoLog })); return novoLog; }
function obterNotificacoes(perfilUsuario) { const data = getData(); return (data.notificacoes || []).filter(n => n.destinatarios.includes(perfilUsuario)).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); }
function obterNotificacoesNaoLidas(perfilUsuario) { return obterNotificacoes(perfilUsuario).filter(n => !n.lida); }
function marcarNotificacaoComoLida(idNotificacao) { const data = getData(); const index = (data.notificacoes || []).findIndex(n => n.id === idNotificacao); if (index !== -1) { data.notificacoes[index].lida = true; saveData(data); document.dispatchEvent(new CustomEvent('notificacaoLida', { detail: { id: idNotificacao } })); return true; } return false; }
function marcarTodasComoLidas(perfilUsuario) { const data = getData(); let algumaAlterada = false; (data.notificacoes || []).forEach(n => { if (n.destinatarios.includes(perfilUsuario) && !n.lida) { n.lida = true; algumaAlterada = true; } }); if (algumaAlterada) { saveData(data); document.dispatchEvent(new CustomEvent('notificacoesLidas', { detail: { perfil: perfilUsuario } })); } }

function obterProdutos() { const data = getData(); return data.produtos || []; }
function obterProdutoPorSku(sku) { return obterProdutos().find(p => p.sku === sku) || null; }
function adicionarProduto(produtoData) { const data = getData(); if (data.produtos.some(p => p.sku === produtoData.sku)) { throw new Error(`Produto com SKU ${produtoData.sku} já existe.`); } const novoProduto = { ...produtoData, quantidade: Number(produtoData.quantidade) || 0, precoCusto: parseFloat(produtoData.precoCusto) || 0, precoVenda: parseFloat(produtoData.precoVenda) || 0, estoqueMinimo: Number(produtoData.estoqueMinimo) || 0, ultimaAtualizacao: new Date().toISOString(), dataCadastro: new Date().toISOString() }; data.produtos.push(novoProduto); saveData(data); adicionarNotificacao({ tipo: "inventario", titulo: "Novo Produto", mensagem: `Produto ${novoProduto.nome} adicionado.`, destinatarios: ["gerente", "inventario"] }); return novoProduto; }
function atualizarProduto(sku, dadosAtualizados) { const data = getData(); const index = data.produtos.findIndex(p => p.sku === sku); if (index === -1) { throw new Error(`Produto ${sku} não encontrado.`); } data.produtos[index] = { ...data.produtos[index], ...dadosAtualizados, quantidade: dadosAtualizados.quantidade !== undefined ? Number(dadosAtualizados.quantidade) : data.produtos[index].quantidade, precoCusto: dadosAtualizados.precoCusto !== undefined ? parseFloat(dadosAtualizados.precoCusto) : data.produtos[index].precoCusto, precoVenda: dadosAtualizados.precoVenda !== undefined ? parseFloat(dadosAtualizados.precoVenda) : data.produtos[index].precoVenda, estoqueMinimo: dadosAtualizados.estoqueMinimo !== undefined ? Number(dadosAtualizados.estoqueMinimo) : data.produtos[index].estoqueMinimo, ultimaAtualizacao: new Date().toISOString() }; saveData(data); adicionarNotificacao({ tipo: "inventario", titulo: "Produto Atualizado", mensagem: `Produto ${data.produtos[index].nome} atualizado.`, destinatarios: ["gerente", "inventario"] }); return data.produtos[index]; }
function removerProduto(sku) { const data = getData(); const produto = data.produtos.find(p => p.sku === sku); if (!produto) { throw new Error(`Produto ${sku} não encontrado.`); } data.produtos = data.produtos.filter(p => p.sku !== sku); saveData(data); adicionarNotificacao({ tipo: "inventario", titulo: "Produto Removido", mensagem: `Produto ${produto.nome} removido.`, destinatarios: ["gerente"] }); return true; }

function registrarMovimentacaoEstoque(movimentacaoData) { const data = getData(); const produtoIndex = data.produtos.findIndex(p => p.sku === movimentacaoData.produtoSku); if (produtoIndex === -1) throw new Error(`Produto ${movimentacaoData.produtoSku} não encontrado.`); if (!TIPOS_MOVIMENTACAO.includes(movimentacaoData.tipo)) throw new Error(`Tipo de movimentação inválido: ${movimentacaoData.tipo}.`); const produto = data.produtos[produtoIndex]; const quantidadeMovimentada = Number(movimentacaoData.quantidade); if (isNaN(quantidadeMovimentada)) throw new Error("Quantidade da movimentação inválida."); const quantidadeAnterior = produto.quantidade; produto.quantidade += quantidadeMovimentada; produto.ultimaAtualizacao = new Date().toISOString(); const novaMovimentacao = { id: gerarIdUnico(data.movimentacoesEstoque || []), data: new Date().toISOString(), ...movimentacaoData, quantidade: quantidadeMovimentada, valorUnitario: parseFloat(movimentacaoData.valorUnitario) || 0 }; if (!data.movimentacoesEstoque) data.movimentacoesEstoque = []; data.movimentacoesEstoque.push(novaMovimentacao); saveData(data); const direcao = quantidadeMovimentada > 0 ? "entrada" : "saída"; const absQuantidade = Math.abs(quantidadeMovimentada); adicionarNotificacao({ tipo: "inventario", titulo: `Mov. Estoque: ${movimentacaoData.tipo}`, mensagem: `Registrada ${direcao} de ${absQuantidade} unid. de ${produto.nome}. Estoque: ${produto.quantidade}.`, destinatarios: ["gerente", "inventario"] }); if (produto.quantidade <= produto.estoqueMinimo && quantidadeAnterior > produto.estoqueMinimo) { adicionarNotificacao({ tipo: "estoque", titulo: `Estoque Baixo: ${produto.nome}`, mensagem: `Produto ${produto.nome} (SKU: ${produto.sku}) atingiu ${produto.quantidade} unidades.`, destinatarios: ["gerente", "inventario"], acao: { tipo: "modal_critico", valor: `Estoque Crítico: ${produto.nome}. Verifique.` } }); } return novaMovimentacao; }
function ajustarEstoqueProduto(sku, novaQuantidadeTotal, motivoObservacao, usuarioIdResponsavel) { const produto = obterProdutoPorSku(sku); if (!produto) throw new Error(`Produto ${sku} não encontrado.`); if (isNaN(novaQuantidadeTotal) || novaQuantidadeTotal < 0) throw new Error("Nova quantidade inválida."); const quantidadeAnterior = produto.quantidade; const diferencaQuantidade = Number(novaQuantidadeTotal) - quantidadeAnterior; const movimentacaoData = { tipo: "Ajuste (inventário)", produtoSku: sku, quantidade: diferencaQuantidade, valorUnitario: produto.precoCusto, origem: "Estoque Físico", destino: "Sistema", documento: `AJ-${Date.now()}`, responsavel: usuarioIdResponsavel, observacao: motivoObservacao || "Ajuste manual" }; return registrarMovimentacaoEstoque(movimentacaoData); }
function obterMovimentacoesEstoque(filtros = {}) { const data = getData(); let movimentacoes = data.movimentacoesEstoque || []; if (filtros.produtoSku) movimentacoes = movimentacoes.filter(m => m.produtoSku === filtros.produtoSku); if (filtros.tipo) movimentacoes = movimentacoes.filter(m => m.tipo === filtros.tipo); /* ... mais filtros ... */ return movimentacoes.sort((a, b) => new Date(b.data) - new Date(a.data)); }

function formatCurrencyGlobal(value) { return `R$ ${Number(value || 0).toFixed(2).replace('.', ',')}`; }
function obterVendasComFiltros(filtros = {}, perfilUsuarioVisualizando = null, idUsuarioVisualizando = null) { const data = getData(); let vendas = data.vendas || []; if (perfilUsuarioVisualizando && perfilUsuarioVisualizando === 'vendas' && idUsuarioVisualizando) { vendas = vendas.filter(v => v.vendedorId === idUsuarioVisualizando); } else if (perfilUsuarioVisualizando && !verificarPermissao(perfilUsuarioVisualizando, 'vendas.historicoCompleto') && idUsuarioVisualizando) { vendas = vendas.filter(v_1 => v_1.vendedorId === idUsuarioVisualizando); } if (filtros.dataInicio) vendas = vendas.filter(v_2 => new Date(v_2.data) >= new Date(filtros.dataInicio)); if (filtros.dataFim) { const df = new Date(filtros.dataFim); df.setHours(23,59,59,999); vendas = vendas.filter(v_3 => new Date(v_3.data) <= df); } if (filtros.vendedorId) vendas = vendas.filter(v_4 => v_4.vendedorId === parseInt(filtros.vendedorId)); if (filtros.cliente && filtros.cliente.trim() !== "") vendas = vendas.filter(v_5 => v_5.cliente && v_5.cliente.toLowerCase().includes(filtros.cliente.toLowerCase())); if (filtros.produtoSku && filtros.produtoSku.trim() !== "") vendas = vendas.filter(v_6 => v_6.itens.some(item => item.sku.toLowerCase().includes(filtros.produtoSku.toLowerCase()))); if (filtros.formaPagamento) vendas = vendas.filter(v_7 => v_7.formaPagamento === filtros.formaPagamento); if (filtros.status) vendas = vendas.filter(v_8 => v_8.status === filtros.status); return vendas.sort((a, b) => new Date(b.data) - new Date(a.data));}
function obterVendaPorId(vendaId) { const data = getData(); return (data.vendas || []).find(v => v.id === vendaId) || null; }
function cancelarVenda(vendaId, usuarioIdResponsavel) { const data = getData(); const vendaIndex = data.vendas.findIndex(v => v.id === vendaId); if (vendaIndex === -1) throw new Error(`Venda ${vendaId} não encontrada.`); const venda = data.vendas[vendaIndex]; if (venda.status === 'cancelada') throw new Error(`Venda ${vendaId} já cancelada.`); const statusAnterior = venda.status; venda.status = 'cancelada'; venda.ultimaAtualizacao = new Date().toISOString(); for (const item of venda.itens) { const movimentacaoReversao = { tipo: "Devolução (cliente)", produtoSku: item.sku, quantidade: Math.abs(item.quantidade), valorUnitario: item.precoUnitario, origem: venda.cliente || "Cliente (Cancelamento)", destino: "Estoque Principal", documento: `CANC-VENDA-${venda.id}`, responsavel: usuarioIdResponsavel, observacao: `Cancelamento venda #${venda.id}. Item: ${item.nomeProduto || item.sku}. Status ant.: ${statusAnterior}.` }; try { registrarMovimentacaoEstoque(movimentacaoReversao); } catch (e) { console.error(`Erro ao reverter estoque para ${item.sku}: ${e.message}`); } } saveData(data); adicionarNotificacao({ tipo: "venda", titulo: "Venda Cancelada", mensagem: `Venda #${venda.id} para ${venda.cliente || 'N/A'} cancelada.`, destinatarios: ["gerente", "vendas"] }); return venda; }
function registrarVenda(vendaInput) { const data = getData(); const usuarioLogado = JSON.parse(sessionStorage.getItem('loggedInUser')); const responsavelId = usuarioLogado ? usuarioLogado.id : null; const novaVenda = { ...vendaInput, id: gerarIdUnico(data.vendas || []), data: vendaInput.data || new Date().toISOString(), status: vendaInput.status || "finalizada", vendedorId: responsavelId || vendaInput.vendedorId, subtotalItens: vendaInput.itens.reduce((sum, item) => sum + (item.precoUnitario * item.quantidade), 0), }; if(!data.vendas) data.vendas = []; data.vendas.push(novaVenda); for (const itemVendido of novaVenda.itens) { const movimentacaoSaida = { tipo: "Saída (venda)", produtoSku: itemVendido.sku, quantidade: -Math.abs(itemVendido.quantidade), valorUnitario: itemVendido.precoUnitario, origem: "Estoque Principal", destino: novaVenda.cliente || "Cliente Desconhecido", documento: `VENDA-${novaVenda.id}`, responsavel: responsavelId, observacao: `Item da venda #${novaVenda.id}` }; try { registrarMovimentacaoEstoque(movimentacaoSaida); } catch (e) { console.error(`Erro mov. saída ${itemVendido.sku}: ${e.message}`); } } adicionarNotificacao({ tipo: "venda", titulo: `Nova Venda (#${novaVenda.id})`, mensagem: `Venda de ${formatCurrencyGlobal(novaVenda.total)} para ${novaVenda.cliente}.`, destinatarios: ["gerente", "vendas"], acao: { tipo: "link", valor: `#sales_history/view/${novaVenda.id}` } }); return novaVenda; }

function obterRelatorioVendasPorPeriodo(dataInicio, dataFim) { const vendasFiltradas = obterVendasComFiltros({ dataInicio, dataFim, status: 'finalizada' }); const relatorio = {}; vendasFiltradas.forEach(venda => { const diaVenda = new Date(venda.data).toISOString().slice(0, 10); if (!relatorio[diaVenda]) { relatorio[diaVenda] = { data: diaVenda, totalValor: 0, quantidadeVendas: 0, totalItens: 0 }; } relatorio[diaVenda].totalValor += venda.total; relatorio[diaVenda].quantidadeVendas++; venda.itens.forEach(item => { relatorio[diaVenda].totalItens += item.quantidade; }); }); return Object.values(relatorio).sort((a,b) => new Date(a.data) - new Date(b.data));}
function obterRelatorioVendasPorVendedor(dataInicio, dataFim) { const vendasFiltradas = obterVendasComFiltros({ dataInicio, dataFim, status: 'finalizada' }); const usuarios = obterUsuarios(); const relatorio = {}; vendasFiltradas.forEach(venda => { const vendedorId = venda.vendedorId; if (!relatorio[vendedorId]) { const vendedorInfo = usuarios.find(u => u.id === vendedorId); relatorio[vendedorId] = { vendedorId: vendedorId, vendedorNome: vendedorInfo ? vendedorInfo.nome : `ID ${vendedorId}`, totalValor: 0, quantidadeVendas: 0 }; } relatorio[vendedorId].totalValor += venda.total; relatorio[vendedorId].quantidadeVendas++; }); return Object.values(relatorio).sort((a,b) => b.totalValor - a.totalValor);}
function obterRelatorioVendasPorProduto(dataInicio, dataFim) { const vendasFiltradas = obterVendasComFiltros({ dataInicio, dataFim, status: 'finalizada' }); const produtos = obterProdutos(); const relatorio = {}; vendasFiltradas.forEach(venda => { venda.itens.forEach(item => { const sku = item.sku; if (!relatorio[sku]) { const produtoInfo = produtos.find(p => p.sku === sku); relatorio[sku] = { produtoSku: sku, produtoNome: produtoInfo ? produtoInfo.nome : `SKU ${sku}`, categoria: produtoInfo ? produtoInfo.categoria : 'N/A', totalQuantidadeVendida: 0, totalValorVendido: 0 }; } relatorio[sku].totalQuantidadeVendida += item.quantidade; relatorio[sku].totalValorVendido += item.subtotal; }); }); return Object.values(relatorio).sort((a,b) => b.totalValorVendido - a.totalValorVendido);}

function calcularCurvaABCProdutos(dataInicio, dataFim) { const vendas = obterVendasComFiltros({ dataInicio, dataFim, status: 'finalizada' }); const produtosData = obterProdutos(); const productRevenue = {}; vendas.forEach(venda => { venda.itens.forEach(item => { productRevenue[item.sku] = (productRevenue[item.sku] || 0) + item.subtotal; }); }); const sortedProducts = Object.entries(productRevenue).map(([sku, revenue]) => { const productInfo = produtosData.find(p => p.sku === sku); return { sku, nome: productInfo ? productInfo.nome : `SKU ${sku}`, categoria: productInfo ? productInfo.categoria : 'N/A', revenue }; }).sort((a, b) => b.revenue - a.revenue); const totalRevenueAllProducts = sortedProducts.reduce((sum, p) => sum + p.revenue, 0); if (totalRevenueAllProducts === 0) return { A: [], B: [], C: [], totalRevenueAllProducts: 0, details: [] }; let cumulativeRevenue = 0; const classifiedProducts = sortedProducts.map(p => { cumulativeRevenue += p.revenue; const percentageOfTotal = (p.revenue / totalRevenueAllProducts) * 100; const cumulativePercentage = (cumulativeRevenue / totalRevenueAllProducts) * 100; let classification = 'C'; if (cumulativePercentage <= 80) classification = 'A'; else if (cumulativePercentage <= 95) classification = 'B'; return { ...p, percentageOfTotal, cumulativePercentage, classification }; }); return { A: classifiedProducts.filter(p => p.classification === 'A'), B: classifiedProducts.filter(p => p.classification === 'B'), C: classifiedProducts.filter(p => p.classification === 'C'), totalRevenueAllProducts, details: classifiedProducts }; }
function calcularLucratividadePorProduto(dataInicio, dataFim) { const vendas = obterVendasComFiltros({ dataInicio, dataFim, status: 'finalizada' }); const produtosData = obterProdutos(); const profitability = {}; vendas.forEach(venda => { venda.itens.forEach(item => { const productInfo = produtosData.find(p => p.sku === item.sku); if (!productInfo) return; if (!profitability[item.sku]) { profitability[item.sku] = { sku: item.sku, nome: productInfo.nome, categoria: productInfo.categoria, totalQuantidadeVendida: 0, totalValorVendido: 0, totalCustoVendido: 0, }; } profitability[item.sku].totalQuantidadeVendida += item.quantidade; profitability[item.sku].totalValorVendido += item.subtotal; profitability[item.sku].totalCustoVendido += productInfo.precoCusto * item.quantidade; }); }); return Object.values(profitability).map(p => { const lucroBruto = p.totalValorVendido - p.totalCustoVendido; const margemLucro = p.totalValorVendido > 0 ? (lucroBruto / p.totalValorVendido) * 100 : 0; return { ...p, lucroBruto, margemLucro }; }).sort((a, b) => b.lucroBruto - a.lucroBruto); }
function calcularRotacaoEstoque(dataInicio, dataFim) { const produtos = obterProdutos(); const resultado = []; let cmvTotalPeriodo = 0; const vendasNoPeriodo = obterVendasComFiltros({ dataInicio, dataFim, status: 'finalizada' }); vendasNoPeriodo.forEach(venda => { venda.itens.forEach(item => { const produtoInfo = produtos.find(p => p.sku === item.sku); if (produtoInfo) { cmvTotalPeriodo += produtoInfo.precoCusto * item.quantidade; } }); }); const valorEstoqueAtualTotal = produtos.reduce((sum, p) => sum + (p.precoCusto * p.quantidade), 0); const rotacaoGeral = valorEstoqueAtualTotal > 0 ? cmvTotalPeriodo / valorEstoqueAtualTotal : 0; resultado.push({ item: "Geral do Estoque", cmv: cmvTotalPeriodo, valorEstoqueMedioAproximado: valorEstoqueAtualTotal, rotacao: rotacaoGeral.toFixed(2) + " vezes" }); produtos.forEach(p => { const quantidadeVendidaNoPeriodo = vendasNoPeriodo.flatMap(v => v.itens).filter(item => item.sku === p.sku).reduce((sum, item) => sum + item.quantidade, 0); const estoqueFinalQtd = p.quantidade; const estoqueInicialAproximadoQtd = p.quantidade + quantidadeVendidaNoPeriodo; const estoqueMedioQtdAproximado = (estoqueInicialAproximadoQtd + estoqueFinalQtd) / 2; const rotacaoProduto = estoqueMedioQtdAproximado > 0 ? quantidadeVendidaNoPeriodo / estoqueMedioQtdAproximado : 0; if (quantidadeVendidaNoPeriodo > 0) { resultado.push({ item: `Prod: ${p.nome} (SKU: ${p.sku})`, quantidadeVendida: quantidadeVendidaNoPeriodo, estoqueMedioQtdAproximado: estoqueMedioQtdAproximado.toFixed(1), rotacao: rotacaoProduto.toFixed(2) + " vezes" }); } }); return resultado; }

function simularPrevisaoDemanda(produtoSku, diasParaPrever = 30, dataInicioHistorico) { /* ... (código existente) ... */ }
function simularDeteccaoAnomaliasVendas(dataInicio, dataFim) { /* ... (código existente) ... */ }
function obterAnomaliasDetectadas() { const data = getData(); return (data.iaInsights?.detectedAnomalies || []).sort((a,b) => new Date(b.data) - new Date(a.data)); }
function marcarAnomaliaComoResolvida(anomaliaId) { /* ... (código existente) ... */ }
function simularPrecificacaoDinamica(produtoSku) { /* ... (código existente) ... */ }
function obterSugestoesPrecificacaoSalvas() { const data = getData(); return data.iaInsights?.pricingSuggestions || []; }
function simularRespostaAssistente(userInput, contextoAtual = {}) { /* ... (código existente) ... */ }
function simularRecomendacoesInteligentes(tipoContexto, dadosContexto = {}) { /* ... (código existente) ... */ }
function simularBuscaAvancadaNLP(textoBusca) { /* ... (código existente) ... */ }
function simularGeracaoDescricaoProdutoNLP(produtoSku) { /* ... (código existente) ... */ }

function adicionarLogIntegracao(tipoIntegracao, plataforma, evento, status, mensagem, detalhes = {}) { const data = getData(); if (!data.logsIntegracao) data.logsIntegracao = []; const novoLog = { id: gerarIdUnico(data.logsIntegracao), timestamp: new Date().toISOString(), tipoIntegracao, plataforma, evento, status, mensagem, detalhes }; data.logsIntegracao.unshift(novoLog); if (data.logsIntegracao.length > 100) data.logsIntegracao.splice(100); saveData(data); return novoLog; }
function obterLogsIntegracao(filtros = {}) { const data = getData(); let logs = data.logsIntegracao || []; /* ... filtros ... */ return logs; }
async function simularSincronizacaoEcommerce(plataforma, config) { /* ... (código existente) ... */ }
async function simularEnvioDadosFiscais(tipoFiscal, config) { /* ... (código existente) ... */ }
async function simularProcessamentoPagamento(provedor, config, dadosPagamento) { /* ... (código existente) ... */ }


if (!localStorage.getItem(ELITE_CONTROL_DATA_KEY)) {
    inicializarDados();
}